(window.webpackJsonp=window.webpackJsonp||[]).push([[627],{2057:function(_,v,t){"use strict";t.r(v);var e=t(5),a=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"feed-流系统设计总纲"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#feed-流系统设计总纲"}},[_._v("#")]),_._v(" Feed 流系统设计总纲")]),_._v(" "),v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[_._v("#")]),_._v(" 简介")]),_._v(" "),v("p",[_._v("差不多十年前，随着功能机的淘汰和智能机的普及，互联网开始进入移动互联网时代，最具代表性的产品就是微博、微信，以及后来的今日头条、快手等。这些移动化联网时代的新产品在过去几年间借着智能手机的风高速成长。")]),_._v(" "),v("p",[_._v("这些产品都是 Feed 流类型产品，由于 Feed 流一般是按照时间“从上往下流动”，非常适合在移动设备端浏览，最终这一类应用就脱颖而出，迅速抢占了上一代产品的市场空间。")]),_._v(" "),v("p",[_._v("Feed 流是 Feed + 流，Feed 的本意是饲料，Feed 流的本意就是有人一直在往一个地方投递新鲜的饲料，如果需要饲料，只需要盯着投递点就可以了，这样就能源源不断获取到新鲜的饲料。 在信息学里面，Feed 其实是一个信息单元，比如一条朋友圈状态、一条微博、一条咨询或一条短视频等，所以 Feed 流就是不停更新的信息单元，只要关注某些发布者就能获取到源源不断的新鲜信息，我们的用户也就可以在移动设备上逐条去浏览这些信息单元。")]),_._v(" "),v("p",[_._v("当前最流行的 Feed 流产品有微博、微信朋友圈、头条的资讯推荐、快手抖音的视频推荐等，还有一些变种，比如私信、通知等，这些系统都是 Feed 流系统，接下来我们会介绍如何设计一个 Feed 流系统架构。")]),_._v(" "),v("h2",{attrs:{id:"feed-流系统特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#feed-流系统特点"}},[_._v("#")]),_._v(" Feed 流系统特点")]),_._v(" "),v("p",[_._v("Feed 流本质上是一个数据流，是将 “N 个发布者的信息单元” 通过 “关注关系” 传送给 “M 个接收者”。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.infoq.cn/resource/image/45/43/4553ba05a331022acbe9ab0cb0bafd43.png",alt:""}})]),_._v(" "),v("p",[_._v("Feed 流系统是一个数据流系统，所以我们核心要看数据。从数据层面看，数据分为三类，分别是：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("发布者的数据：发布者产生数据，然后数据需要按照发布者组织，需要根据发布者查到所有数据，比如微博的个人页面、朋友圈的个人相册等。")])]),_._v(" "),v("li",[v("p",[_._v("关注关系：系统中个体间的关系，微博中是关注，是单向流，朋友圈是好友，是双向流。不管是单向还是双向，当发布者发布一条信息时，该条信息的流动永远是单向的。")])]),_._v(" "),v("li",[v("p",[_._v("接收者的数据：从不同发布者那里获取到的数据，然后通过某种顺序（一般为时间）组织在一起，比如微博的首页、朋友圈首页等。这些数据具有时间热度属性，越新的数据越有价值，越新的数据就要排在最前面。")])])]),_._v(" "),v("p",[_._v("针对这三类数据，我们可以有如下定义：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("存储库：存储发布者的数据，永久保存。")])]),_._v(" "),v("li",[v("p",[_._v("关注表：用户关系表，永久保存。")])]),_._v(" "),v("li",[v("p",[_._v("同步库：存储接收者的时间热度数据，只需要保留最近一段时间的数据即可。")])])]),_._v(" "),v("p",[_._v("设计 Feed 流系统时最核心的是确定清楚产品层面的定义，需要考虑的因素包括：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("产品用户规模：用户规模在十万、千万、十亿级时，设计难度和侧重点会不同。")])]),_._v(" "),v("li",[v("p",[_._v("关注关系（单向、双写）：如果是双向，那么就不会有大 V，否则会有大 V 存在。")])])]),_._v(" "),v("p",[_._v("上述是选择数据存储系统最核心的几个考虑点，除此之外，还有一些需要考虑的：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如何实现 Meta 和 Feed 内容搜索？")])]),_._v(" "),v("li",[v("p",[_._v("虽然 Feed 流系统本身可以不需要搜索，但是一个 Feed 流产品必须要有搜索，否则信息发现难度会加大，用户留存率会大幅下降。")])]),_._v(" "),v("li",[v("p",[_._v("Feed 流的顺序是时间还是其他分数，比如个人的喜好程度？")])]),_._v(" "),v("li",[v("p",[_._v("双向关系时由于关系很紧密，一定是按时间排序，就算一个关系很紧密的人发了一条空消息或者低价值消息，那我们也会需要关注了解的。")])]),_._v(" "),v("li",[v("p",[_._v("单向关系时，那么可能就会存在大 V，大 V 的粉丝数量理论极限就是整个系统的用户数，有一些产品会让所有用户都默认关注产品负责人，这种产品中，该负责人就是最大的大 V，粉丝数就是用户规模。")])]),_._v(" "),v("li",[v("p",[_._v("接下来，我们看看整个 Feed 流系统如何设计。")])])]),_._v(" "),v("h2",{attrs:{id:"feed-流系统设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#feed-流系统设计"}},[_._v("#")]),_._v(" Feed 流系统设计")]),_._v(" "),v("p",[_._v("上一节，我们提前思考了 Feed 流系统的几个关键点，接下来，在这一节，我们自顶向下来设计一个 Feed 流系统。")]),_._v(" "),v("h3",{attrs:{id:"_1-产品定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-产品定义"}},[_._v("#")]),_._v(" 1. 产品定义")]),_._v(" "),v("p",[_._v("第一步，我们首先需要定义产品，我们要做的产品是哪一种类型，常见的类型有：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("微博类")])]),_._v(" "),v("li",[v("p",[_._v("朋友圈类")])]),_._v(" "),v("li",[v("p",[_._v("抖音类")])]),_._v(" "),v("li",[v("p",[_._v("私信类")])])]),_._v(" "),v("p",[_._v("接着，再详细看一下这几类产品的异同：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("类型")]),_._v(" "),v("th",[_._v("关注关系")]),_._v(" "),v("th",[_._v("是否有大V")]),_._v(" "),v("th",[_._v("时效性")]),_._v(" "),v("th",[_._v("排序")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("微博类")]),_._v(" "),v("td",[_._v("单向")]),_._v(" "),v("td",[_._v("有")]),_._v(" "),v("td",[_._v("秒~分")]),_._v(" "),v("td",[_._v("时间")])]),_._v(" "),v("tr",[v("td",[_._v("抖音类")]),_._v(" "),v("td",[_._v("单向/无")]),_._v(" "),v("td",[_._v("有")]),_._v(" "),v("td",[_._v("秒~分")]),_._v(" "),v("td",[_._v("推荐")])]),_._v(" "),v("tr",[v("td",[_._v("朋友圈类")]),_._v(" "),v("td",[_._v("双向")]),_._v(" "),v("td",[_._v("无")]),_._v(" "),v("td",[_._v("秒")]),_._v(" "),v("td",[_._v("时间")])]),_._v(" "),v("tr",[v("td",[_._v("私信类")]),_._v(" "),v("td",[_._v("双向")]),_._v(" "),v("td",[_._v("无")]),_._v(" "),v("td",[_._v("秒")]),_._v(" "),v("td",[_._v("时间")])])])]),_._v(" "),v("p",[_._v("上述对比中，只对比各类产品最核心、或者最根本特点，其他次要的不考虑。比如微博中互相关注后就是双向关注了，但是这个不是微博的立命之本，只是补充，无法撼动根本。")]),_._v(" "),v("p",[_._v("从上面表格可以看出来，主要分为两种区分：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("关注关系是单向还是双向：")])]),_._v(" "),v("li",[v("p",[_._v("如果是单向，那么可能就会存在大 V 效应，同时时效性可以低一些，比如到分钟级别；")])]),_._v(" "),v("li",[v("p",[_._v("如果是双向，那就是好友，好友的数量有限，那么就不会有大 V，因为每个人的精力有限，他不可能主动加几千万的好友，这时候因为关系更精密，时效性要求会更高，需要都秒级别。")])]),_._v(" "),v("li",[v("p",[_._v("排序是时间还是推荐：")])]),_._v(" "),v("li",[v("p",[_._v("用户对 feed 流最容易接受的就是时间，目前大部分都是时间。")])]),_._v(" "),v("li",[v("p",[_._v("但是有一些场景，是从全网数据里面根据用户的喜好给用户推荐和用户喜好度最匹配的内容，这个时候就需要用推荐了，这种情况一般也会省略掉关注了，相对于关注了全网所有用户，比如抖音、头条等。")])]),_._v(" "),v("li",[v("p",[_._v("确定了产品类型后，还需要继续确定的是系统设计目标：需要支持的最大用户数是多少？十万、百万、千万还是亿？")])])]),_._v(" "),v("p",[_._v("用户数很少的时候，就比较简单，这里我们主要考虑 亿级用户 的情况，因为如果系统能支持亿级，那么其他量级也能支持。为了支持亿级规模的用户，主要子系统选型时需要考虑水平扩展能力以及一些子系统的可用性和可靠性了，因为系统大了后，任何一个子系统的不稳定都很容易波及整个系统。")]),_._v(" "),v("h3",{attrs:{id:"_2-存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-存储"}},[_._v("#")]),_._v(" 2. 存储")]),_._v(" "),v("p",[_._v("我们先来看看最重要的存储，不管是哪种同步模式，在存储上都是一样的，我们定义用户消息的存储为存储库。存储库主要满足三个需求：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("可靠存储用户发送的消息，不能丢失。否则就找不到自己曾经发布到朋友圈状态了。")])]),_._v(" "),v("li",[v("p",[_._v("读取某个人发布过的所有消息，比如个人主页等。")])]),_._v(" "),v("li",[v("p",[_._v("数据永久保存。")])])]),_._v(" "),v("p",[_._v("所以，存储库最重要的特征就是两点：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("数据可靠、不丢失。")])]),_._v(" "),v("li",[v("p",[_._v("由于数据要永久保存，数据会一直增长，所以要易于水平扩展。")])])]),_._v(" "),v("p",[_._v("综上，可以选为存储库的系统大概有两类：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("特点")]),_._v(" "),v("th",[_._v("分布式NoSQL")]),_._v(" "),v("th",[_._v("关系型数据库（分库分表）")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("可靠性")]),_._v(" "),v("td",[_._v("极高")]),_._v(" "),v("td",[_._v("高")])]),_._v(" "),v("tr",[v("td",[_._v("水平扩展能力")]),_._v(" "),v("td",[_._v("线性")]),_._v(" "),v("td",[_._v("需要改造")])]),_._v(" "),v("tr",[v("td",[_._v("水平扩展速度")]),_._v(" "),v("td",[_._v("毫秒")]),_._v(" "),v("td",[_._v("无")])]),_._v(" "),v("tr",[v("td",[_._v("常见系统")]),_._v(" "),v("td",[_._v("Tablestore、Bigtable")]),_._v(" "),v("td",[_._v("MySQL、PostgreSQL")])])])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("对于可靠性，分布式 NoSQL 的可靠性要高于关系型数据库，这个可能有违很多人的认知。主要是关系型数据库发展很长时间了，且很成熟了，数据放在上面大家放心，而分布式 NoSQL 数据库发展晚，使用的并不多，不太信任。但是，分布式 NoSQL 需要存储的数据量更多，对数据可靠性的要求也加严格，所以一般都是存储三份，可靠性会更高。目前在一些云厂商中的关系型数据库因为采用了和分布式 NoSQL 类似的方式，所以可靠性也得到了大幅提高。")])]),_._v(" "),v("li",[v("p",[_._v("水平扩展能力：对于分布式 NoSQL 数据库，数据天然是分布在多台机器上，当一台机器上的数据量增大后，可以通过自动分裂两部分，然后将其中一半的数据迁移到另一台机器上去，这样就做到了线性扩展。而关系型数据库需要在扩容时再次分库分表。")])])]),_._v(" "),v("p",[_._v("所以，结论是：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果是自建系统，且不具备分布式 NoSQL 数据库运维能力，且数据规模不大，那么可以使用 MySQL，这样可以撑一段时间。")])]),_._v(" "),v("li",[v("p",[_._v("如果是基于云服务，那么就用分布式 NoSQL，比如 Tablestore 或 Bigtable。")])]),_._v(" "),v("li",[v("p",[_._v("如果数据规模很大，那么也要用分布式 NoSQL，否则就是走上一条不归路。")])])]),_._v(" "),v("p",[_._v("如果使用 Tablestore，那么存储库表设计结构如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("主键列")]),_._v(" "),v("th",[_._v("第一列主键")]),_._v(" "),v("th",[_._v("第二列主键")]),_._v(" "),v("th",[_._v("属性列")]),_._v(" "),v("th",[_._v("属性列")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("列名")]),_._v(" "),v("td",[_._v("user_id")]),_._v(" "),v("td",[_._v("message_id")]),_._v(" "),v("td",[_._v("content")]),_._v(" "),v("td",[_._v("other")])]),_._v(" "),v("tr",[v("td",[_._v("解释")]),_._v(" "),v("td",[_._v("消息发送者用户ID")]),_._v(" "),v("td",[_._v("消息顺序ID，可以使用timestamp。")]),_._v(" "),v("td",[_._v("内容")]),_._v(" "),v("td",[_._v("其他内容")])])])]),_._v(" "),v("p",[_._v("到此，我们确定了存储库的选型，那么系统架构的轮廓有了：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.infoq.cn/resource/image/78/7a/781105d7d06afbdbdc568a531cb1d07a.png",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_3-同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-同步"}},[_._v("#")]),_._v(" 3. 同步")]),_._v(" "),v("p",[_._v("系统规模和产品类型，以及存储系统确定后，我们可以确定同步方式，常见的方式有三种：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("推模式（也叫写扩散）：和名字一样，就是一种推的方式，发送者发送了一个消息后，立即将这个消息推送给接收者，但是接收者此时不一定在线，那么就需要有一个地方存储这个数据，这个存储的地方我们称为：同步库。推模式也叫写扩散的原因是，一个消息需要发送个多个粉丝，那么这条消息就会复制多份，写放大，所以也叫写扩散。这种模式下，对同步库的要求就是写入能力极强和稳定。读取的时候因为消息已经发到接收者的收件箱了，只需要读一次自己的收件箱即可，读请求的量极小，所以对读的 QPS 需求不大。归纳下，推模式中对同步库的要求只有一个：写入能力强。")])]),_._v(" "),v("li",[v("p",[_._v("拉模式（也叫读扩散）：这种是一种拉的方式，发送者发送了一条消息后，这条消息不会立即推送给粉丝，而是写入自己的发件箱，当粉丝上线后再去自己关注者的发件箱里面去读取，一条消息的写入只有一次，但是读取最多会和粉丝数一样，读会放大，所以也叫读扩散。拉模式的读写比例刚好和写扩散相反，那么对系统的要求是：读取能力强。另外这里还有一个误区，很多人在最开始设计 feed 流系统时，首先想到的是拉模式，因为这种和用户的使用体感是一样的，但是在系统设计上这种方式有不少痛点，最大的是每个粉丝需要记录自己上次读到了关注者的哪条消息，如果有 1000 个关注者，那么这个人需要记录 1000 个位置信息，这个量和关注量成正比的，远比用户数要大的多，这里要特别注意，虽然在产品前期数据量少的时候这种方式可以应付，但是量大了后就会事倍功半，得不偿失，切记切记。")])]),_._v(" "),v("li",[v("p",[_._v("推拉结合模式：推模式在单向关系中，因为存在大 V，那么一条消息可能会扩散几百万次，但是这些用户中可能有一半多是僵尸，永远不会上线，那么就存在资源浪费。而拉模式下，在系统架构上会很复杂，同时需要记录的位置信息是天量，不好解决，尤其是用户量多了后会成为第一个故障点。基于此，所以有了推拉结合模式，大部分用户的消息都是写扩散，只有大 V 是读扩散，这样既控制了资源浪费，又减少了系统设计复杂度。但是整体设计复杂度还是要比推模式复杂。")])])]),_._v(" "),v("p",[_._v("用图表对比：")]),_._v(" "),v("p",[_._v("类型|推模式|拉模式|推拉结合模式")]),_._v(" "),v("p",[_._v("写放大|高|无|中")]),_._v(" "),v("p",[_._v("读放大|无|高|中")]),_._v(" "),v("p",[_._v("用户读取延时|毫秒|秒|秒")]),_._v(" "),v("p",[_._v("读写比例|1:99|99:1|~50:50")]),_._v(" "),v("p",[_._v("系统要求|写能力强|读能力强|读写都适中")]),_._v(" "),v("p",[_._v("常见系统|Tablestore、Bigtable 等 LSM 架构的分布式 NoSQL|Redis、memcache 等缓存系统或搜索系统(推荐排序场景)|两者结合")]),_._v(" "),v("p",[_._v("架构复杂度|简单|复杂|更复杂")]),_._v(" "),v("p",[_._v("介绍完同步模式中所有场景和模式后，我们归纳下：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果产品中是双向关系，那么就采用推模式。")])]),_._v(" "),v("li",[v("p",[_._v("如果产品中是单向关系，且用户数少于 1000 万，那么也采用推模式，足够了。")])]),_._v(" "),v("li",[v("p",[_._v("如果产品是单向关系，单用户数大于 1000 万，那么采用推拉结合模式，这时候可以从推模式演进过来，不需要额外重新推翻重做。")])]),_._v(" "),v("li",[v("p",[_._v("永远不要只用拉模式。")])]),_._v(" "),v("li",[v("p",[_._v("如果是一个初创企业，先用推模式，快速把系统设计出来，然后让产品去验证、迭代，等客户数大幅上涨到 1000 万后，再考虑升级为推拉集合模式。")])]),_._v(" "),v("li",[v("p",[_._v("如果是按推荐排序，那么是另外的考虑了，架构会完全不一样，这个后面专门文章介绍。")])])]),_._v(" "),v("p",[_._v("如果选择了 Tablestore，那么同步库表设计结构如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("主键列")]),_._v(" "),v("th",[_._v("第一列主键")]),_._v(" "),v("th",[_._v("第二列主键")]),_._v(" "),v("th",[_._v("属性列")]),_._v(" "),v("th",[_._v("属性列")]),_._v(" "),v("th",[_._v("属性列")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("列名")]),_._v(" "),v("td",[_._v("user_id")]),_._v(" "),v("td",[_._v("sequence_id")]),_._v(" "),v("td",[_._v("sender_id")]),_._v(" "),v("td",[_._v("message_id")]),_._v(" "),v("td",[_._v("other")])]),_._v(" "),v("tr",[v("td",[_._v("解释")]),_._v(" "),v("td",[_._v("消息接收者用户ID")]),_._v(" "),v("td",[_._v("消息顺序ID，可以使用timestamp + send_user_id，也可以直接使用Tablestore的自增列。")]),_._v(" "),v("td",[_._v("发送者的用户ID")]),_._v(" "),v("td",[_._v("store_table中的message_id列的值，也就是消息ID。通过sender_id和message_id可以到store_table中查询到消息内容")]),_._v(" "),v("td",[_._v("其他内容，同步库中不需要包括消息内容。")])])])]),_._v(" "),v("p",[_._v("确定了同步库的架构如下：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.infoq.cn/resource/image/c3/ff/c3024e7819572abe943a2bac7533eaff.png",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_4-元数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-元数据"}},[_._v("#")]),_._v(" 4. 元数据")]),_._v(" "),v("p",[_._v("前面介绍了同步和存储后，整个 Feed 流系统的基础功能完成了，但是对于一个完整 Feed 流产品而言，还缺元数据部分，接下来，我们看元数据如何处理：")]),_._v(" "),v("p",[_._v("Feed 流系统中的元数据主要包括：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("用户详情和列表。")])]),_._v(" "),v("li",[v("p",[_._v("关注或好友关系。")])]),_._v(" "),v("li",[v("p",[_._v("推送 session 池。")])])]),_._v(" "),v("p",[_._v("我们接下来逐一来看。")]),_._v(" "),v("h4",{attrs:{id:"_4-1-用户详情和列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-用户详情和列表"}},[_._v("#")]),_._v(" 4.1 用户详情和列表")]),_._v(" "),v("p",[_._v("主要是用户的详情，包括用户的各种自定义属性和系统附加的属性，这部分的要求只需要根据用户 ID 查询到就可以了。")]),_._v(" "),v("p",[_._v("可以采用的分布式 NoSQL 系统或者关系型数据库都可以。")]),_._v(" "),v("p",[_._v("如果使用 NoSQL 数据库 Tablestore，那么用户详情表设计结构如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("主键顺序")]),_._v(" "),v("th",[_._v("第一列主键")]),_._v(" "),v("th",[_._v("属性列-1")]),_._v(" "),v("th",[_._v("属性列-2")]),_._v(" "),v("th",[_._v("…")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("字段名")]),_._v(" "),v("td",[_._v("user_id")]),_._v(" "),v("td",[_._v("nick_name")]),_._v(" "),v("td",[_._v("gender")]),_._v(" "),v("td",[_._v("other")])]),_._v(" "),v("tr",[v("td",[_._v("备注")]),_._v(" "),v("td",[_._v("主键列，用于唯一确定一个用户")]),_._v(" "),v("td",[_._v("用户昵称，用户自定义属性")]),_._v(" "),v("td",[_._v("用户性别，用户自定义属性")]),_._v(" "),v("td",[_._v("其他属性，包括用户自定义属性列和系统附加属性列。Tablestore是FreeSchema类型的，可以随时在任何一行增加新列而不影响原有数据。")])])])]),_._v(" "),v("h4",{attrs:{id:"_4-2-关注或好友关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-关注或好友关系"}},[_._v("#")]),_._v(" 4.2 关注或好友关系")]),_._v(" "),v("p",[_._v("这部分是存储关系，查询的时候需要支持查询关注列表或者粉丝列表，或者直接好友列表，这里就需要根据多个属性列查询需要索引能力，这里，存储系统也可以采用两类，关系型、分布式 NoSQL 数据库。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果已经有了关系型数据库了，且数据量较少，则选择关系型数据库，比如 MySQL 等。")])]),_._v(" "),v("li",[v("p",[_._v("如果数据量比较大，这个时候就有两种选择：")])]),_._v(" "),v("li",[v("p",[_._v("a. 需要分布式事务，可以采用支持分布式事务的系统，比如分布式关系型数据库。")])]),_._v(" "),v("li",[v("p",[_._v("a. 使用具有索引的系统，比如云上的 Tablestore，更简单，吞吐更高，扩容能力也一并解决了。")])])]),_._v(" "),v("p",[_._v("如果使用 Tablestore，那么关注关系表设计结构如下：")]),_._v(" "),v("p",[_._v("Table：user_relation_table")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("主键顺序")]),_._v(" "),v("th",[_._v("第一列主键")]),_._v(" "),v("th",[_._v("第一列主键")]),_._v(" "),v("th",[_._v("属性列")]),_._v(" "),v("th",[_._v("属性列")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("Table字段名")]),_._v(" "),v("td",[_._v("user_id")]),_._v(" "),v("td",[_._v("follow_user_id")]),_._v(" "),v("td",[_._v("timestamp")]),_._v(" "),v("td",[_._v("other")])]),_._v(" "),v("tr",[v("td",[_._v("备注")]),_._v(" "),v("td",[_._v("用户ID")]),_._v(" "),v("td",[_._v("粉丝用户ID")]),_._v(" "),v("td",[_._v("关注时间")]),_._v(" "),v("td",[_._v("其他属性列")])])])]),_._v(" "),v("p",[_._v("多元索引的索引结构：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("Table字段名")]),_._v(" "),v("th",[_._v("user_id")]),_._v(" "),v("th",[_._v("follow_user_id")]),_._v(" "),v("th",[_._v("timestamp")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("是否Index")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")])]),_._v(" "),v("tr",[v("td",[_._v("是否enableSortAndAgg")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")])]),_._v(" "),v("tr",[v("td",[_._v("是否store")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")])])])]),_._v(" "),v("p",[_._v("查询的时候：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果需要查询某个人的粉丝列表：使用 TermQuery 查询固定 user_id，且按照 timestamp 排序。")])]),_._v(" "),v("li",[v("p",[_._v("如果需要查询某个人的关注列表：使用 TermQuery 查询固定 follow_user_id，且按照 timestamp 排序。")])]),_._v(" "),v("li",[v("p",[_._v("当前数据写入 Table 后，需要 5~10 秒钟延迟后会在多元索引中查询到，未来会优化到 2 秒以内。")])])]),_._v(" "),v("blockquote",[v("p",[_._v("除了使用多元索引外，还可以使用 GlobalIndex。")])]),_._v(" "),v("h4",{attrs:{id:"_4-3-推送-session-池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-推送-session-池"}},[_._v("#")]),_._v(" 4.3 推送 session 池")]),_._v(" "),v("p",[_._v("思考一个问题，发送者将消息发送后，接收者如何知道自己有新消息来了？客户端周期性去刷新？如果是这样子，那么系统的读请求压力会随着客户端增长而增长，这时候就会有一个风险，比如平时的设备在线率是 20%~30%，突然某天平台爆发了一个热点消息，大量休眠设备登陆，这个时候就会出现“查询风暴”，一下子就把系统打垮了，所有的用户都不能用了。")]),_._v(" "),v("p",[_._v("解决这个问题的一个思路是，在服务端维护一个推送 session 池，这个里面记录哪些用户在线，然后当用户 A 发送了一条消息给用户 B 后，服务端在写入存储库和同步库后，再通知一下 session 池中的用户 B 的 session，告诉他：你有新消息了。然后 session-B 再去读消息，然后有消息后将消息推送给客户端。或者有消息后给客户端推送一下有消息了，客户端再去拉。")]),_._v(" "),v("p",[_._v("这个 session 池使用在同步中，但是本质还是一个元数据，一般只需要存在于内存中即可，但是考虑到 failover 情况，那就需要持久化，这部分数据由于只需要指定单 Key 查询，用分布式 NoSQL 或关系型数据库都可以，一般复用当前的系统即可。")]),_._v(" "),v("p",[_._v("如果使用 Tablestore，那么 session 表设计结构如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("主键列顺序")]),_._v(" "),v("th",[_._v("第一列主键")]),_._v(" "),v("th",[_._v("第二列主键")]),_._v(" "),v("th",[_._v("属性列")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("列名")]),_._v(" "),v("td",[_._v("user_id")]),_._v(" "),v("td",[_._v("device_id")]),_._v(" "),v("td",[_._v("last_sequence_id")])]),_._v(" "),v("tr",[v("td",[_._v("备注")]),_._v(" "),v("td",[_._v("接收者用户ID")]),_._v(" "),v("td",[_._v("设备ID，同一个用户可能会有多个设备，不同设备的读取位置可能不一致，所以这里需要一个设备ID。如果不需要支持多终端，则这一列可以省略。")]),_._v(" "),v("td",[_._v("该接收者已经推送给客户端的最新的顺序ID")])])])]),_._v(" "),v("h3",{attrs:{id:"_5-评论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-评论"}},[_._v("#")]),_._v(" 5. 评论")]),_._v(" "),v("p",[_._v("除了私信类型外，其他的 feed 流类型中，都有评论功能，评论的属性和存储库差不多，但是多了一层关系：被评论的消息，所以只要将评论按照被被评论消息分组组织即可，然后查询时也是一个范围查询就行。这种查询方式很简单，用不到关系型数据库中复杂的事务、join 等功能，很适合用分布式 NoSQL 数据库来存储。")]),_._v(" "),v("p",[_._v("所以，一般的选择方式就是：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果系统中已经有了分布式 NoSQL 数据库，比如 Tablestore、Bigtable 等，那么直接用这些即可。")])]),_._v(" "),v("li",[v("p",[_._v("如果没有上述系统，那么如果有 MySQL 等关系型数据库，那就选关系型数据库即可。")])]),_._v(" "),v("li",[v("p",[_._v("如果选择了 Tablestore，那么“评论表”设计结构如下：")])])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("主键列顺序")]),_._v(" "),v("th",[_._v("第一列主键")]),_._v(" "),v("th",[_._v("第二列主键")]),_._v(" "),v("th",[_._v("属性列")]),_._v(" "),v("th",[_._v("属性列")]),_._v(" "),v("th",[_._v("属性列")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("字段名")]),_._v(" "),v("td",[_._v("message_id")]),_._v(" "),v("td",[_._v("comment_id")]),_._v(" "),v("td",[_._v("comment_content")]),_._v(" "),v("td",[_._v("reply_to")]),_._v(" "),v("td",[_._v("other")])]),_._v(" "),v("tr",[v("td",[_._v("备注")]),_._v(" "),v("td",[_._v("微博ID或朋友圈ID等消息的ID")]),_._v(" "),v("td",[_._v("这一条评论的ID")]),_._v(" "),v("td",[_._v("评论内容")]),_._v(" "),v("td",[_._v("回复给哪个用户")]),_._v(" "),v("td",[_._v("其他")])])])]),_._v(" "),v("p",[_._v("如果需要搜索评论内容，那么对这张表建立多元索引即可。")]),_._v(" "),v("h3",{attrs:{id:"_6-赞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-赞"}},[_._v("#")]),_._v(" 6. 赞")]),_._v(" "),v("p",[_._v("最近几年，“赞”或“like”功能很流行，赞功能的实现和评论类似，只是比评论少了一个内容，所以选择方式和评论一样。")]),_._v(" "),v("p",[_._v("如果选择了 Tablestore，那么“赞表”设计结构同评论表，这里就不再赘述了。")]),_._v(" "),v("p",[_._v("系统架构中加了元数据系统后的架构如下：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.infoq.cn/resource/image/42/be/424654e21f553ad4ef64bbdee01fc0be.png",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_7-搜索"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-搜索"}},[_._v("#")]),_._v(" 7. 搜索")]),_._v(" "),v("p",[_._v("到此，我们已经介绍完了 Feed 流系统的主题架构，Feed 流系统算是完成了。但是 Feed 流产品上还未结束，对于所有的 feed 流产品都需要有搜索能力，比如下面场景：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("微博中的搜索用户。")])]),_._v(" "),v("li",[v("p",[_._v("搜索微博内容。")])]),_._v(" "),v("li",[v("p",[_._v("微信中搜索好友等。")])])]),_._v(" "),v("p",[_._v("这些内容搜索只需要字符匹配到即可，不需要非常复杂的相关性算法，所以只需要有能支持分词的检索功能即可，所以一般有两种做法：")]),_._v(" "),v("p",[_._v("使用搜索引擎，将存储库的内容和用户信息表内容推送给搜索系统，搜索的时候直接访问搜索系统。")]),_._v(" "),v("p",[_._v("使用具备全文检索能力的数据库，比如最新版的 MySQL、MongoDB 或者 Tablestore。")]),_._v(" "),v("p",[_._v("所以，选择的原则如下：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果存储库使用了 MySQL 或者 Tablestore，那么直接选择这两个系统就可以了。")])]),_._v(" "),v("li",[v("p",[_._v("如果整个系统都没使用 MySQL、Tablestore，且已经使用了搜索系统，那么可以直接复用搜索系统，其他场景都不应该再额外加一个搜索系统进来，徒添复杂度。")])])]),_._v(" "),v("p",[_._v("如果使用 Tablestore，那么只需要在相应表上建立多元索引即可：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果需要对用户名支持搜索，那么需要对 user_table 建立多元索引，其中的 nick_name 需要是 Text 类型，且单字分词。")])]),_._v(" "),v("li",[v("p",[_._v("如果需要对 Feed 流内容支持搜索，那么需要对存储库表：store_table 建立多元索引，这样就能直接对 Feed 流内容进行各种复杂查询了，包括多条件筛选、全文检索等。")])])]),_._v(" "),v("p",[_._v("系统架构中加了搜索功能后的架构如下：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.infoq.cn/resource/image/88/ac/8803b48df3fd149065cbc32f1966afac.png",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_8-排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-排序"}},[_._v("#")]),_._v(" 8. 排序")]),_._v(" "),v("p",[_._v("目前的 Feed 流系统中的排序方式有两种，一种是时间，一种是分数。")]),_._v(" "),v("p",[_._v("我们常用的微博、朋友圈、私信这些都是时间线类型的，因为这些产品定义中，需要我们主动关注某些人后才会看到这些人发表的内容，这个时候，最重要的是实时性，而不是发布质量，就算关注人发布了一条垃圾信息，我们也会被动看到。这种类型的产品适用于按照时间线排序。这一篇我们介绍的架构都是基于时间类型的。")]),_._v(" "),v("p",[_._v("另外一种是不需要关注任何人，我们能看到的都是系统希望我们看到的，系统在后台会分析我们的每个人的爱好，然后给每个人推送差异化的、各自喜欢的内容，这一种的架构和基于时间的完全不一样，我们在后续的推荐类型中专门介绍。")]),_._v(" "),v("h3",{attrs:{id:"_9-删除-feed-内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-删除-feed-内容"}},[_._v("#")]),_._v(" 9. 删除 Feed 内容")]),_._v(" "),v("p",[_._v("在 Feed 流应用中有一个问题，就是如果用户删除了之前发表的内容，系统该如何处理？因为系统里面有写扩散，那么删除的时候是不是也要写扩散一遍？这样的话，删除就不及时了，很难应对法律法规要求的快速删除。")]),_._v(" "),v("p",[_._v("针对这个问题，我们在之前设计的时候，同步表中只有消息 ID，没有消息内容，在用户读取的时候需要到存储库中去读消息内容，那么我们可以直接删除存储库中的这一条消息，这样用户读取的时候使用消息 ID 是读不到数据的，也就相当于删除的内容，而且删除速度会很快。除了直接删除外，另外一种办法是逻辑删除，对于删除的 feed 内容，只做标记，当查询到带有标记的数据时就认为删除了。")]),_._v(" "),v("h3",{attrs:{id:"_10-更新-feed-内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-更新-feed-内容"}},[_._v("#")]),_._v(" 10. 更新 Feed 内容")]),_._v(" "),v("p",[_._v("更新和删除 Feed 处理逻辑一样，如果使用了支持多版本的存储系统，比如 Tablestore，那么也可以支持编辑版本，和现在的微博一样。")]),_._v(" "),v("h3",{attrs:{id:"_11-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-总结"}},[_._v("#")]),_._v(" 11. 总结")]),_._v(" "),v("p",[_._v("上面介绍了不同子功能的特点和系统要求，能满足需求的系统主要有两类，一类是阿里云的 Tablestore 单系统，一类是开源组件组成的组合系统。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("开源组件组成的组合系统：包括 MySQL、Redis、HBase 等，这些系统单个都不能解决 Feed 流系统中遇到的问题，需要组合在一起，各司其职才能完成一个 Feed 流系统，适用于热衷开源系统，人多且喜欢运维操作的团队。")])]),_._v(" "),v("li",[v("p",[_._v("Tablestore 单系统：只使用 Tablestore 单个系统就能解决上述的所有问题，这时候肯定有人要问？你是不是在吹牛？ 这里不是吹牛，Tablestore 在三年前就已经开始重视 Feed 流类型业务，之前也发表过多篇文章介绍，功能上也在专门为 Feed 流系统特别定制设计，所以到今天，只使用 Tablestore 一款产品，是可以满足上述需求的。选择 Tablestore 做 Feed 流系统的用户具有以下一些特征：")])]),_._v(" "),v("li",[v("p",[_._v("产品设计目标规模大，千万级或亿级。")])]),_._v(" "),v("li",[v("p",[_._v("不喜欢运维，喜欢专注于开发。")])]),_._v(" "),v("li",[v("p",[_._v("高效率团队，希望尽快将产品实现落地。")])]),_._v(" "),v("li",[v("p",[_._v("希望一劳永逸，未来系统随着用户规模增长可以自动扩容。")])]),_._v(" "),v("li",[v("p",[_._v("希望能按量付费，用户少的时候费用低，等用户增长起来后费用在跟随用户数增长。")])]),_._v(" "),v("li",[v("p",[_._v("如果具有上述四个特征的任何一个，那么都是适合于用 Tablestore。")])])]),_._v(" "),v("h2",{attrs:{id:"架构实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#架构实践"}},[_._v("#")]),_._v(" 架构实践")]),_._v(" "),v("p",[_._v("上面我们介绍了 Feed 流系统的设计理论，具体到不同的类型中，会有不同的侧重点，下面会逐一介绍。")]),_._v(" "),v("h3",{attrs:{id:"朋友圈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#朋友圈"}},[_._v("#")]),_._v(" 朋友圈")]),_._v(" "),v("p",[_._v("朋友圈是一种典型的 Feed 流系统，关系是双写关系，关系有上限，排序按照时间，如果有个人持续产生垃圾内容，那就只能屏蔽掉 TA，这一种类型就是典型的写扩散模型。")]),_._v(" "),v("p",[_._v("我们接下来会在文章《朋友圈类系统架构设计》中详细介绍朋友圈类型 Feed 流系统的设计。")]),_._v(" "),v("h3",{attrs:{id:"微博"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微博"}},[_._v("#")]),_._v(" 微博")]),_._v(" "),v("p",[_._v("微博也是一种非常典型的 Feed 流系统，但不同于朋友圈，关系是单向的，那么也就会产生大 V，这个时候就需要读写扩散模式，用读扩散解决大 V 问题。同时，微博也是主动关注类型的产品，所以排序也只能是时间，如果按照推荐排序，那么效果就会比较差。")]),_._v(" "),v("p",[_._v("接下里会在文章《微博类系统架构设计》中详细介绍微博类型 Feed 流系统的设计。")]),_._v(" "),v("h3",{attrs:{id:"头条"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#头条"}},[_._v("#")]),_._v(" 头条")]),_._v(" "),v("p",[_._v("头条是最近几年快速崛起的一款应用，在原有微博的 Feed 流系统上产生了进化，用户不需要主动关注其他人，只要初始浏览一些内容后，系统就会自动判断出你的喜好，然后后面再根据你的喜好给你推荐你可能会喜好的内容，训练时间长了后，推送的内容都会是你最喜欢看的。")]),_._v(" "),v("p",[_._v("后面，我们会在文章《头条类系统架构设计》中详细介绍头条类型 Feed 流系统的设计。")]),_._v(" "),v("h3",{attrs:{id:"私信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#私信"}},[_._v("#")]),_._v(" 私信")]),_._v(" "),v("p",[_._v("私信也算是一种简单的 Feed 流系统，或者也可以认为是一种变相的 IM，都是单对单的，没有群。我们后面也会有一篇文章《私信类系统架构设计》中做详细介绍。")]),_._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("p",[_._v("上面我们介绍了 Feed 流系统的整体框架，主要是产品定义、同步、存储、元数据、评论、赞、排序和搜索等内容，由于篇幅有限，每一章节都介绍的比较简单。读者如果对某一部分看完后仍然有疑问，可以继续再文后提问，我会继续去完善这篇文章，希望未来读者看完这篇文章后，就可以轻轻松松设计出一个亿级规模的 Feed 流系统。")]),_._v(" "),v("p",[_._v("另外，我们也欢迎有兴趣的读者一起来完成这个系列，帮忙实现朋友圈、微博、头条或者私信类型的文章，有任何问题都欢迎来讨论。")]),_._v(" "),v("p",[v("strong",[_._v("本文转载云栖社区")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("原文链接")]),_._v("：")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://shimo.im/sheets/WHrazKQV5A0O4kne/Z9yox",target:"_blank",rel:"noopener noreferrer"}},[v("strong",[_._v("https://shimo.im/sheets/WHrazKQV5A0O4kne/Z9yox")]),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=a.exports}}]);